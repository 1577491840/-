# 位运算
1. 按位与&
   **对应位都**为1时，结果才为1，否则为0。
2. 按位或（|)
   **对应位有1个为1**，结果就为1。
3. 按位异或（  ^  ) XOR
   **对应位不同**时结果为1，相同时为0
4. 按位取反( ~ )
   **每一位取反**：0变1，1变0
5. 左移  ( << )
   **所有位向左移动**，低位补0
6. 右移( >> )
   **所有位向右移动**，高位处理方式不同
7.检查s[i]第i位是否为1
  (S[i] >> j) & 1


# 快速幂
```cpp
int inv100 = ksm(100LL, MOD - 2, MOD);
//100LL：需要求逆元的数，使用 LL 后缀确保是 long long 类型
//MOD - 2：根据费马小定理，幂次为 MOD-2
//MOD：模数（必须是质数）
//ksm()：快速幂函数，计算 100^(MOD-2) mod MOD
//这种计算通常出现在需要处理百分比的题目中，比如：
// 假设概率是 25%，要计算其模 MOD 下的值
int probability = 25 * inv100 % MOD;  // 等价于 25/100 mod MOD
```



# 模运算
1. 模加法  
```cpp
(a + b) mod MOD = ((a mod MOD) + (b mod MOD)) mod MOD
```
2. 模减法
注意： 需要加 MOD 再取模，防止结果为负数
```cpp
(a - b) mod MOD = ((a mod MOD) - (b mod MOD) + MOD) mod MOD
```
3. 模乘法
和加法相似
```cpp
(a * b) mod MOD = ((a mod MOD) * (b mod MOD)) mod MOD
```
4. 模除法(模运算没有除法，其实是乘上逆元）
