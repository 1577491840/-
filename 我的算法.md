# 位运算
1. 按位与&
   **对应位都**为1时，结果才为1，否则为0。
2. 按位或（|)
   **对应位有1个为1**，结果就为1。
3. 按位异或（  ^  ) XOR
   **对应位不同**时结果为1，相同时为0
4. 按位取反( ~ )
   **每一位取反**：0变1，1变0
5. 左移  ( << )
   **所有位向左移动**，低位补0
6. 右移( >> )
   **所有位向右移动**，高位处理方式不同
7.检查s[i]第i位是否为1
  (S[i] >> j) & 1

## 第一场A（快速幂，逆元，费马小定理）
# 快速幂
```cpp
long long ksm(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1) {  // 当前二进制位为1
            res = res * a;
        }
        a = a * a;    // a平方
        b >>= 1;      // b右移一位
    }
    return res;
}
```
### 快速模幂
```cpp
long long ksm_mod(long long a, long long b, long long mod) {
    long long res = 1 % mod;
    a %= mod;
    while (b > 0) {
        if (b & 1) {
            res = (res * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}
int inv100 = ksm(100LL, MOD - 2, MOD);
```



# 模运算
1. 模加法  
```cpp
(a + b) mod MOD = ((a mod MOD) + (b mod MOD)) mod MOD
```
2. 模减法
注意： 需要加 MOD 再取模，防止结果为负数
```cpp
(a - b) mod MOD = ((a mod MOD) - (b mod MOD) + MOD) mod MOD
```
3. 模乘法
和加法相似
```cpp
(a * b) mod MOD = ((a mod MOD) * (b mod MOD)) mod MOD
```
4. 模除法(模运算没有除法，其实是乘上逆元）
