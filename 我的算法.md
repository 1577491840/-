# 位运算
1. 按位与&
   **对应位都**为1时，结果才为1，否则为0。
2. 按位或（|)
   **对应位有1个为1**，结果就为1。
3. 按位异或（  ^  ) XOR
   **对应位不同**时结果为1，相同时为0
4. 按位取反( ~ )
   **每一位取反**：0变1，1变0
5. 左移  ( << )
   **所有位向左移动**，低位补0
6. 右移( >> )
   **所有位向右移动**，高位处理方式不同
7.检查s[i]第i位是否为1
  (S[i] >> j) & 1

## 第一场A（快速幂，逆元，费马小定理）
# 快速幂
```cpp
long long ksm(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1) {  // 当前二进制位为1
            res = res * a;
        }
        a = a * a;    // a平方
        b >>= 1;      // b右移一位
    }
    return res;
}
```
### 快速模幂
```cpp
long long ksm_mod(long long a, long long b, long long mod) {
    long long res = 1 % mod;
    a %= mod;
    while (b > 0) {
        if (b & 1) {
            res = (res * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}
int inv100 = ksm(100LL, MOD - 2, MOD);
```



# 模运算
1. 模加法  
```cpp
(a + b) mod MOD = ((a mod MOD) + (b mod MOD)) mod MOD
```
2. 模减法
注意： 需要加 MOD 再取模，防止结果为负数
```cpp
(a - b) mod MOD = ((a mod MOD) - (b mod MOD) + MOD) mod MOD
```
3. 模乘法
和加法相似
```cpp
(a * b) mod MOD = ((a mod MOD) * (b mod MOD)) mod MOD
```
4. 模除法(模运算没有除法，其实是乘上逆元）
### 费马小定理
如果 p 是一个质数，且整数 a 不是 p 的倍数（即 a 与 p 互质），那么：
a^(p-1) % p == 1 % p
也即a在模p的逆元为：
a^(-1) = a^(p-2)%p
代码：
```cpp
const int mod = 998244353;  // 这是一个质数

// 求 a 在模 mod 下的逆元
int inv_a = ksm(a, mod - 2);  // 使用费马小定理

// 在题目中的应用：求 100 的逆元
int inv100 = ksm(100, mod - 2);
```
# .
.
.
### 注意运算顺序，以后还是尽量写
```cpp
t =  t * t % mod;
```
而不是
```cpp
t *= t%mod;
```
因为
t%mod 先计算
t *= (t%mod) 相当于 t = t * (t % mod)
# 数论
